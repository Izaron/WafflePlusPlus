// Generated by the Waffle++ code generator. DO NOT EDIT!
// source: counter.h

#include <algorithm>
#include <map>
#include <vector>

#include <waffle/modules/signals/signals.h>

#include "counter.h"

namespace Waffle {

namespace Impl {

// pointer to sender/receiver object and signal/slot string code
using StorageUnit = std::pair<const SignalBase*, std::string_view>;

inline std::map<StorageUnit, std::vector<StorageUnit>> SIGNALS_STORAGE;

template<>
std::string_view GetSignalName(void(model::Counter::*ptr)(int)) {
    if (ptr == &model::Counter::ValueChanged) {
        return "model::Counter::ValueChanged";
    }
    __builtin_unreachable();
}

template<>
std::string_view GetSlotName(void(model::Counter::*ptr)(int)) {
    if (ptr == &model::Counter::SetValue) {
        return "model::Counter::SetValue";
    }
    __builtin_unreachable();
}

void Connect(const SignalBase* sender, std::string_view signal, const SignalBase* receiver, std::string_view slot) {
    auto& vec = SIGNALS_STORAGE[{sender, signal}];
    vec.emplace_back(receiver, slot);
}

template<typename... Args>
void CallSlot(const SignalBase* constReceiver, std::string_view slot, Args... args);

template<>
void CallSlot(const SignalBase* constReceiver, std::string_view slot, int value) {
    SignalBase* receiver = const_cast<SignalBase*>(constReceiver);
    if (slot == "model::Counter::SetValue") {
        dynamic_cast<model::Counter*>(receiver)->SetValue(value);
    }
}


} // namespace Impl

SignalBase::~SignalBase() {
    // remove as a signal
    std::erase_if(Impl::SIGNALS_STORAGE, [this](const auto& item) {
        const auto& key = item.first;
        const auto* ptr = key.first;
        return ptr == this;
    });

    // remove as a slot
    for (auto& iter : Impl::SIGNALS_STORAGE) {
        auto& vec = iter.second;
        vec.erase(std::remove_if(vec.begin(), vec.end(), [this](const auto& item) {
            return item.first == this;
        }));
    }
}

} // namespace Waffle

void model::Counter::ValueChanged(int newValue) {
    auto& vec = Waffle::Impl::SIGNALS_STORAGE[{this, "model::Counter::ValueChanged"}];
    for (const auto& [receiver, slot] : vec) {
        Waffle::Impl::CallSlot(receiver, slot, newValue);
    }
}
