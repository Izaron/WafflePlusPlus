// Generated by the Waffle++ code generator. DO NOT EDIT!
// source: employee.h

#include <array>
#include <deque>
#include <forward_list>
#include <list>
#include <optional>
#include <sstream>
#include <vector>

#include <waffle/modules/json_dump/json_dump.h>

#include "employee.h"

namespace Waffle {

namespace Impl {

template<class, template<class...> class> inline constexpr bool is_specialization = false;
template<template<class...> class T, class... Args> inline constexpr bool is_specialization<T<Args...>, T> = true;

template<typename T> concept JsonNullable = is_specialization<T, std::optional>;
template<typename T> concept JsonArray =
    is_specialization<T, std::vector> || is_specialization<T, std::deque> ||
    is_specialization<T, std::list> || is_specialization<T, std::forward_list> ||
    is_specialization<T, std::array>;
template<typename T> concept JsonObject = std::is_class_v<T> && !is_specialization<T, std::basic_string>;

template<typename T>
void DumpRoot(nlohmann::json& j, const T& value);

template<typename T>
void ParseRoot(T& t, const nlohmann::json& value);

template<JsonNullable T>
void DumpNullable(nlohmann::json& j, const T& value) {
    if (value.has_value()) {
        DumpRoot(j, *value);
    }
}

template<JsonNullable T>
void ParseNullable(T& t, const nlohmann::json& value) {
    if (!value.is_null()) {
        ParseRoot(t.emplace(), value);
    }
}

template<JsonArray T>
void DumpArray(nlohmann::json& j, const T& value) {
    for (auto iter = value.begin(); iter != value.end(); ++iter) {
        DumpRoot(j.emplace_back(), *iter);
    }
}

template<JsonArray T>
void ParseArray(T& t, const nlohmann::json& value) {
    for (auto iter = value.begin(); iter != value.end(); ++iter) {
        ParseRoot(t.emplace_back(), *iter);
    }
}

template<JsonObject T>
void DumpObject(nlohmann::json& j, const T& value);

template<JsonObject T>
void ParseObject(T& t, const nlohmann::json& value);

template<typename T>
void DumpPrimitive(nlohmann::json& j, const T value) {
    j = value;
}

template<typename T>
void ParsePrimitive(T& t, const nlohmann::json& value) {
    t = value;
}

template<>
inline void DumpObject(nlohmann::json& j, const model::Employee& value) {
    DumpPrimitive(j["Id"], value.Id);
    DumpPrimitive(j["Name"], value.Name);
    DumpPrimitive(j["Salary"], value.Salary);
}

template<>
inline void ParseObject(model::Employee& t, const nlohmann::json& value) {
    ParsePrimitive(t.Id, value["Id"]);
    ParsePrimitive(t.Name, value["Name"]);
    ParsePrimitive(t.Salary, value["Salary"]);
}

template<typename T>
void DumpRoot(nlohmann::json& j, const T& value) {
    if constexpr (JsonNullable<T>) {
        DumpNullable(j, value);
    } else if constexpr (JsonArray<T>) {
        DumpArray(j, value);
    } else if constexpr (JsonObject<T>) {
        DumpObject(j, value);
    } else {
        DumpPrimitive(j, value);
    }
}

template<typename T>
void ParseRoot(T& t, const nlohmann::json& value) {
    if constexpr (JsonNullable<T>) {
        ParseNullable(t, value);
    } else if constexpr (JsonArray<T>) {
        ParseArray(t, value);
    } else if constexpr (JsonObject<T>) {
        ParseObject(t, value);
    } else {
        ParsePrimitive(t, value);
    }
}

} // namespace Impl

template<typename T>
nlohmann::json ToJson(const T& value) {
    nlohmann::json j;
    Impl::DumpRoot(j, value);
    return j;
}

template nlohmann::json ToJson<model::Employee>(const model::Employee&);

template<typename T>
T FromJson(const nlohmann::json& value) {
    T t;
    Impl::ParseRoot(t, value);
    return t;
}

template model::Employee FromJson<model::Employee>(const nlohmann::json&);

} // namespace Waffle
