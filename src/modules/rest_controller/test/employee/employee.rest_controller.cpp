// Generated by the Waffle++ code generator. DO NOT EDIT!
// source: employee.h

#include <waffle/modules/json_dump/json_dump.h>
#include <waffle/modules/rest_controller/rest_controller.h>

#include <lib/string_util/string_util.h>

#include "employee.h"

namespace Waffle {

namespace Impl {

using PathParts = std::vector<std::string_view>;

inline constexpr std::string_view DELIMS = "/?=&";

inline bool PatternMatches(std::string_view pattern, std::string_view requestPath) {
    PathParts patternParts = StringUtil::SplitByDelims(pattern, DELIMS);
    PathParts requestPathParts = StringUtil::SplitByDelims(requestPath, DELIMS);

    if (patternParts.size() != requestPathParts.size()) {
        return false;
    }

    for (size_t i = 0; i < patternParts.size(); ++i) {
        if (patternParts[i].front() == '{' && patternParts[i].back() == '}') {
            // this is a placeholder like '{id}'
            continue;
        }
        if (patternParts[i] != requestPathParts[i]) {
            return false;
        }
    }

    return true;
}

template<typename T>
T FindPlaceholderValue(std::string_view pattern, std::string_view requestPath, std::string_view placeholder);

template<>
inline std::string_view FindPlaceholderValue<std::string_view>(std::string_view pattern, std::string_view requestPath, std::string_view placeholder) {
    // assuming that `PatternMatches(pattern, requestPath) == true`
    PathParts patternParts = StringUtil::SplitByDelims(pattern, DELIMS);
    PathParts requestPathParts = StringUtil::SplitByDelims(requestPath, DELIMS);

    const auto iter = std::find(patternParts.begin(), patternParts.end(), placeholder);
    return requestPathParts[std::distance(patternParts.begin(), iter)];
}

template<>
inline size_t FindPlaceholderValue<size_t>(std::string_view pattern, std::string_view requestPath, std::string_view placeholder) {
    std::string_view str = FindPlaceholderValue<std::string_view>(pattern, requestPath, placeholder);
    size_t result;
    std::sscanf(str.data(), "%zu", &result);
    return result;
}

template<>
inline double FindPlaceholderValue<double>(std::string_view pattern, std::string_view requestPath, std::string_view placeholder) {
    std::string_view str = FindPlaceholderValue<std::string_view>(pattern, requestPath, placeholder);
    double result;
    std::sscanf(str.data(), "%lf", &result);
    return result;
}

} // namespace Impl

template<>
HttpResponse ProcessRequest(model::EmployeeController& handler, const HttpRequest& request) {
    try {
        HttpResponse response;
        response.StatusCode = 200;
        if (request.Method == "POST" && Impl::PatternMatches("/employees", request.Path)) {
            model::Employee arg1 = FromJson<model::Employee>(nlohmann::json::parse(request.Body));
            handler.Add(std::move(arg1));
            return response;
        }
        if (request.Method == "GET" && Impl::PatternMatches("/employees/{id}", request.Path)) {
            size_t arg1 = Impl::FindPlaceholderValue<size_t>("/employees/{id}", request.Path, "{" "id" "}");
            auto result = handler.FindById(arg1);
            response.Body = ToJson(result).dump(/*indent=*/4);
            return response;
        }
        if (request.Method == "GET" && Impl::PatternMatches("/employees/find?lowerBound={lowerBound}&upperBound={upperBound}", request.Path)) {
            double arg1 = Impl::FindPlaceholderValue<double>("/employees/find?lowerBound={lowerBound}&upperBound={upperBound}", request.Path, "{" "lowerBound" "}");
            double arg2 = Impl::FindPlaceholderValue<double>("/employees/find?lowerBound={lowerBound}&upperBound={upperBound}", request.Path, "{" "upperBound" "}");
            auto result = handler.FindBySalaryRange(arg1, arg2);
            response.Body = ToJson(result).dump(/*indent=*/4);
            return response;
        }
        if (request.Method == "GET" && Impl::PatternMatches("/employees", request.Path)) {
            auto result = handler.FindAll();
            response.Body = ToJson(result).dump(/*indent=*/4);
            return response;
        }
        if (request.Method == "DELETE" && Impl::PatternMatches("/employees/{id}", request.Path)) {
            size_t arg1 = Impl::FindPlaceholderValue<size_t>("/employees/{id}", request.Path, "{" "id" "}");
            handler.DeleteById(arg1);
            return response;
        }
        throw std::runtime_error("Can't handle " + request.Method + " request with path \"" + request.Path + "\"");
    } catch (const std::exception& ex) {
        nlohmann::json bodyJson;
        bodyJson["reason"] = ex.what();

        HttpResponse response;
        response.StatusCode = 500;
        response.Body = bodyJson.dump(/*indent=*/4);
        return response;
    }
}

} // namespace Waffle
