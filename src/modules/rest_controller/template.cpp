// Generated by the Waffle++ code generator. DO NOT EDIT!
// source: {{ source_file }}

#include <waffle/modules/json_dump/json_dump.h>
#include <waffle/modules/rest_controller/rest_controller.h>

#include <lib/string_util/string_util.h>

#include "{{ source_file }}"

namespace Waffle {

namespace Impl {

using PathParts = std::vector<std::string_view>;

inline bool PatternMatches(std::string_view pattern, std::string_view requestPath) {
    PathParts patternParts = StringUtil::SplitByDelim(pattern, '/');
    PathParts requestPathParts = StringUtil::SplitByDelim(requestPath, '/');

    if (patternParts.size() != requestPathParts.size()) {
        return false;
    }

    for (size_t i = 0; i < patternParts.size(); ++i) {
        if (patternParts[i].front() == '{' && patternParts[i].back() == '}') {
            // this is a placeholder like '{id}'
            continue;
        }
        if (patternParts[i] != requestPathParts[i]) {
            return false;
        }
    }

    return true;
}

inline std::string_view FindPlaceholderValue(std::string_view pattern, std::string_view requestPath, std::string_view placeholder) {
    // assuming that `PatternMatches(pattern, requestPath) == true`
    PathParts patternParts = StringUtil::SplitByDelim(pattern, '/');
    PathParts requestPathParts = StringUtil::SplitByDelim(requestPath, '/');

    const auto iter = std::find(patternParts.begin(), patternParts.end(), placeholder);
    return requestPathParts[std::distance(patternParts.begin(), iter)];
}

} // namespace Impl

## for struct in structs
template<>
HttpResponse ProcessRequest({{ struct.name }}& handler, const HttpRequest& request) {
    try {
        HttpResponse response;
        response.Code = 200;
## for method in struct.methods
        if (request.Method == "{{ method.http_method }}" && Impl::PatternMatches("{{ method.mapping }}", request.Path)) {
## for param in method.params
            {{ param.type }} arg{{ loop.index1 }} = {};
## endfor
{% if method.return_type == "void" %}
            handler.{{ method.name }}();
{% else %}
            auto result = handler.{{ method.name }}();
            response.Body = ToJson(result).dump(/*indent=*/4);
{% endif %}
            return response;
        }
## endfor
        throw std::runtime_error("Can't handle " + request.Method + " request with path \"" + request.Path + "\"");
    } catch (const std::exception& ex) {
        HttpResponse response;
        response.Code = 500;
        response.Body = ex.what();
        return response;
    }
}

## endfor
} // namespace Waffle
