// Generated by the Waffle++ code generator. DO NOT EDIT!
// source: structs.h

#include <memory>
#include <optional>

#include "structs.h"

namespace Waffle {

namespace Impl {

template<typename T>
struct Traits;

template<>
struct Traits<model::Robot> {
    struct Ops {
        void(*ForwardFunc)(void* ptr, double distance);
        void(*TurnFunc)(void* ptr, double degrees);
        void(*GoToFunc)(void* ptr, double x, double y);
        double(*GetXFunc)(void* ptr);
        double(*GetYFunc)(void* ptr);
        void(*Destruct)(void* ptr);
    };

    template<typename Object>
    static constexpr Ops OpsFor {
        .ForwardFunc = [](void* ptr, double distance) { return static_cast<Object*>(ptr)->Forward(distance); },
        .TurnFunc = [](void* ptr, double degrees) { return static_cast<Object*>(ptr)->Turn(degrees); },
        .GoToFunc = [](void* ptr, double x, double y) { return static_cast<Object*>(ptr)->GoTo(x, y); },
        .GetXFunc = [](void* ptr) { return static_cast<Object*>(ptr)->GetX(); },
        .GetYFunc = [](void* ptr) { return static_cast<Object*>(ptr)->GetY(); },
        .Destruct = [](void* ptr) { delete static_cast<Object*>(ptr); }
    };
};

template<>
struct Traits<model::Stringer> {
    struct Ops {
        std::string(*StringFunc)(void* ptr);
        void(*Destruct)(void* ptr);
    };

    template<typename Object>
    static constexpr Ops OpsFor {
        .StringFunc = [](void* ptr) { return static_cast<Object*>(ptr)->String(); },
        .Destruct = [](void* ptr) { delete static_cast<Object*>(ptr); }
    };
};

} // namespace Impl

// ------------- declare poly_obj ------------- //
template<typename T>
class poly_obj;

template<>
class poly_obj<model::Robot> {
public:
    template<typename Object>
    poly_obj(Object&& object) {
        Obj_ = std::aligned_alloc(alignof(Object), sizeof(Object));
        new (Obj_) Object{std::move(object)};
        Ops_ = &Impl::Traits<model::Robot>::OpsFor<Object>;
    }
    ~poly_obj() {
        Ops_->Destruct(Obj_);
    }

    void Forward(double distance) { return Ops_->ForwardFunc(Obj_, distance); }
    void Turn(double degrees) { return Ops_->TurnFunc(Obj_, degrees); }
    void GoTo(double x, double y) { return Ops_->GoToFunc(Obj_, x, y); }
    double GetX() const { return Ops_->GetXFunc(Obj_); }
    double GetY() const { return Ops_->GetYFunc(Obj_); }

private:
    void* Obj_;
    const Impl::Traits<model::Robot>::Ops* Ops_;
};

template<>
class poly_obj<model::Stringer> {
public:
    template<typename Object>
    poly_obj(Object&& object) {
        Obj_ = std::aligned_alloc(alignof(Object), sizeof(Object));
        new (Obj_) Object{std::move(object)};
        Ops_ = &Impl::Traits<model::Stringer>::OpsFor<Object>;
    }
    ~poly_obj() {
        Ops_->Destruct(Obj_);
    }

    std::string String() const { return Ops_->StringFunc(Obj_); }

private:
    void* Obj_;
    const Impl::Traits<model::Stringer>::Ops* Ops_;
};

// ------------- declare poly_ref ------------- //
template<typename T>
class poly_ref;

template<>
class poly_ref<model::Robot> {
public:
    template<typename Object>
    poly_ref(Object& object) {
        Obj_ = &object;
        Ops_ = &Impl::Traits<model::Robot>::OpsFor<Object>;
    }

    void Forward(double distance) { return Ops_->ForwardFunc(Obj_, distance); }
    void Turn(double degrees) { return Ops_->TurnFunc(Obj_, degrees); }
    void GoTo(double x, double y) { return Ops_->GoToFunc(Obj_, x, y); }
    double GetX() const { return Ops_->GetXFunc(Obj_); }
    double GetY() const { return Ops_->GetYFunc(Obj_); }

private:
    void* Obj_;
    const Impl::Traits<model::Robot>::Ops* Ops_;
};

template<>
class poly_ref<model::Stringer> {
public:
    template<typename Object>
    poly_ref(Object& object) {
        Obj_ = &object;
        Ops_ = &Impl::Traits<model::Stringer>::OpsFor<Object>;
    }

    std::string String() const { return Ops_->StringFunc(Obj_); }

private:
    void* Obj_;
    const Impl::Traits<model::Stringer>::Ops* Ops_;
};

// ------------- declare const_poly_ref ------------- //
template<typename T>
class const_poly_ref;

template<>
class const_poly_ref<model::Robot> {
public:
    template<typename Object>
    const_poly_ref(const Object& object) {
        Obj_ = &object;
        Ops_ = &Impl::Traits<model::Robot>::OpsFor<Object>;
    }

    double GetX() const { return Ops_->GetXFunc(Obj_); }
    double GetY() const { return Ops_->GetYFunc(Obj_); }

private:
    void* Obj_;
    const Impl::Traits<model::Robot>::Ops* Ops_;
};

template<>
class const_poly_ref<model::Stringer> {
public:
    template<typename Object>
    const_poly_ref(const Object& object) {
        Obj_ = &object;
        Ops_ = &Impl::Traits<model::Stringer>::OpsFor<Object>;
    }

    std::string String() const { return Ops_->StringFunc(Obj_); }

private:
    void* Obj_;
    const Impl::Traits<model::Stringer>::Ops* Ops_;
};

// ------------- declare poly_ptr ------------- //
template<typename T>
class poly_ptr {
public:
    poly_ptr() = default;
    poly_ptr(std::nullptr_t) {};

    template<typename Object>
    poly_ptr(Object* object) {
        if (object != nullptr) {
            ref_.emplace(*object);
        }
    }

    poly_ref<T>& operator*() {
        return ref_.value();
    }

    poly_ref<T>* operator->() {
        return &ref_.value();
    }

private:
    std::optional<poly_ref<T>> ref_;
};

// ------------- declare const_poly_ptr ------------- //
template<typename T>
class const_poly_ptr {
public:
    const_poly_ptr() = default;
    const_poly_ptr(std::nullptr_t) {};

    template<typename Object>
    const_poly_ptr(const Object* object) {
        if (object != nullptr) {
            ref_.emplace(*object);
        }
    }

    const_poly_ref<T>& operator*() {
        return ref_.value();
    }

    const_poly_ref<T>* operator->() {
        return &ref_.value();
    }

private:
    std::optional<const_poly_ref<T>> ref_;
};

} // namespace Waffle
