// Generated by the Waffle++ code generator. DO NOT EDIT!
// source: {{ source_file }}

#include <memory>
#include <optional>

#include "{{ source_file }}"

namespace Waffle {

// ------------- declare poly_obj ------------- //
template<typename T>
class poly_obj;

## for struct in structs
template<>
class poly_obj<{{ struct.qualified_name }}> {
public:
    template<typename Object>
    poly_obj(Object&& object)
        : object_ptr_{std::make_unique<object_impl<Object>>(std::move(object))}
    {}

## for method in struct.methods
    {{ method.return_type }} {{ method.name }}({{ method.signature }}){{ method.qualifiers }} { return object_ptr_->{{ method.name }}({{ method.args }}); }
## endfor

private:
    struct object_interface {
        virtual ~object_interface() = default;

## for method in struct.methods
        virtual {{ method.return_type }} {{ method.name }}({{ method.signature }}){{ method.qualifiers }} = 0;
## endfor
    };

    template<typename Object>
    struct object_impl : object_interface {
        object_impl(Object&& object) : object_{std::move(object)} {}
        Object object_;

## for method in struct.methods
        {{ method.return_type }} {{ method.name }}({{ method.signature }}){{ method.qualifiers }} override { return object_.{{ method.name }}({{ method.args }}); }
## endfor
    };

    std::unique_ptr<object_interface> object_ptr_;
};

## endfor
// ------------- declare poly_ref ------------- //
template<typename T>
class poly_ref;

## for struct in structs
template<>
class poly_ref<{{ struct.qualified_name }}> {
public:
    template<typename Object>
    poly_ref(Object& object)
        : object_ptr_{std::make_unique<object_impl<Object>>(object)}
    {}

## for method in struct.methods
    {{ method.return_type }} {{ method.name }}({{ method.signature }}){{ method.qualifiers }} { return object_ptr_->{{ method.name }}({{ method.args }}); }
## endfor

private:
    struct object_interface {
        virtual ~object_interface() = default;

## for method in struct.methods
        virtual {{ method.return_type }} {{ method.name }}({{ method.signature }}){{ method.qualifiers }} = 0;
## endfor
    };

    template<typename Object>
    struct object_impl : object_interface {
        object_impl(Object& object) : object_{object} {}
        Object& object_;

## for method in struct.methods
        {{ method.return_type }} {{ method.name }}({{ method.signature }}){{ method.qualifiers }} override { return object_.{{ method.name }}({{ method.args }}); }
## endfor
    };

    std::unique_ptr<object_interface> object_ptr_;
};

## endfor
// ------------- declare const_poly_ref ------------- //
template<typename T>
class const_poly_ref;

## for struct in structs
template<>
class const_poly_ref<{{ struct.qualified_name }}> {
public:
    template<typename Object>
    const_poly_ref(const Object& object)
        : object_ptr_{std::make_unique<object_impl<Object>>(object)}
    {}

## for method in struct.methods
{% if method.qualifiers == " const" %}
    {{ method.return_type }} {{ method.name }}({{ method.signature }}){{ method.qualifiers }} { return object_ptr_->{{ method.name }}({{ method.args }}); }
{% endif %}
## endfor

private:
    struct object_interface {
        virtual ~object_interface() = default;

## for method in struct.methods
{% if method.qualifiers == " const" %}
        virtual {{ method.return_type }} {{ method.name }}({{ method.signature }}){{ method.qualifiers }} = 0;
{% endif %}
## endfor
    };

    template<typename Object>
    struct object_impl : object_interface {
        object_impl(const Object& object) : object_{object} {}
        const Object& object_;

## for method in struct.methods
{% if method.qualifiers == " const" %}
        {{ method.return_type }} {{ method.name }}({{ method.signature }}){{ method.qualifiers }} override { return object_.{{ method.name }}({{ method.args }}); }
{% endif %}
## endfor
    };

    const std::unique_ptr<const object_interface> object_ptr_;
};

## endfor
// ------------- declare poly_ptr ------------- //
template<typename T>
class poly_ptr {
public:
    poly_ptr() = default;
    poly_ptr(std::nullptr_t) {};

    template<typename Object>
    poly_ptr(Object* object) {
        if (object != nullptr) {
            ref_.emplace(*object);
        }
    }

    poly_ref<T>& operator*() {
        return ref_.value();
    }

    poly_ref<T>* operator->() {
        return &ref_.value();
    }

private:
    std::optional<poly_ref<T>> ref_;
};

// ------------- declare const_poly_ptr ------------- //
template<typename T>
class const_poly_ptr {
public:
    const_poly_ptr() = default;
    const_poly_ptr(std::nullptr_t) {};

    template<typename Object>
    const_poly_ptr(const Object* object) {
        if (object != nullptr) {
            ref_.emplace(*object);
        }
    }

    const_poly_ref<T>& operator*() {
        return ref_.value();
    }

    const_poly_ref<T>* operator->() {
        return &ref_.value();
    }

private:
    std::optional<const_poly_ref<T>> ref_;
};

} // namespace Waffle
