// Generated by the Waffle++ code generator. DO NOT EDIT!
// source: {{ source_file }}

#include <memory>
#include <optional>

#include "{{ source_file }}"

namespace Waffle {

namespace Impl {

template<typename T>
struct Traits;

## for struct in structs
template<>
struct Traits<{{ struct.qualified_name }}> {
    struct Ops {
## for method in struct.methods
{% if method.signature == "" %}
        {{ method.return_type }}(*{{ method.name }}Func)(void* ptr);
{% else %}
        {{ method.return_type }}(*{{ method.name }}Func)(void* ptr, {{ method.signature }});
{% endif %}
## endfor
        void(*Destruct)(void* ptr);
    };

    template<typename Object>
    static constexpr Ops OpsFor {
## for method in struct.methods
{% if method.signature == "" %}
        .{{ method.name }}Func = [](void* ptr) { return static_cast<Object*>(ptr)->{{ method.name }}(); },
{% else %}
        .{{ method.name }}Func = [](void* ptr, {{ method.signature }}) { return static_cast<Object*>(ptr)->{{ method.name }}({{ method.args }}); },
{% endif %}
## endfor
        .Destruct = [](void* ptr) { delete static_cast<Object*>(ptr); }
    };
};

## endfor
} // namespace Impl

// ------------- declare poly_obj ------------- //
template<typename T>
class poly_obj;

## for struct in structs
template<>
class poly_obj<{{ struct.qualified_name }}> {
public:
    template<typename Object>
    poly_obj(Object&& object) {
        Obj_ = std::aligned_alloc(alignof(Object), sizeof(Object));
        new (Obj_) Object{std::move(object)};
        Ops_ = &Impl::Traits<{{ struct.qualified_name }}>::OpsFor<Object>;
    }
    ~poly_obj() {
        Ops_->Destruct(Obj_);
    }

## for method in struct.methods
{% if method.signature == "" %}
    {{ method.return_type }} {{ method.name }}(){{ method.qualifiers }} { return Ops_->{{ method.name }}Func(Obj_); }
{% else %}
    {{ method.return_type }} {{ method.name }}({{ method.signature }}){{ method.qualifiers }} { return Ops_->{{ method.name }}Func(Obj_, {{ method.args }}); }
{% endif %}
## endfor

private:
    void* Obj_;
    const Impl::Traits<{{ struct.qualified_name }}>::Ops* Ops_;
};

## endfor
// ------------- declare poly_ref ------------- //
template<typename T>
class poly_ref;

## for struct in structs
template<>
class poly_ref<{{ struct.qualified_name }}> {
public:
    template<typename Object>
    poly_ref(Object& object) {
        Obj_ = &object;
        Ops_ = &Impl::Traits<{{ struct.qualified_name }}>::OpsFor<Object>;
    }

## for method in struct.methods
{% if method.signature == "" %}
    {{ method.return_type }} {{ method.name }}(){{ method.qualifiers }} { return Ops_->{{ method.name }}Func(Obj_); }
{% else %}
    {{ method.return_type }} {{ method.name }}({{ method.signature }}){{ method.qualifiers }} { return Ops_->{{ method.name }}Func(Obj_, {{ method.args }}); }
{% endif %}
## endfor

private:
    void* Obj_;
    const Impl::Traits<{{ struct.qualified_name }}>::Ops* Ops_;
};

## endfor
// ------------- declare const_poly_ref ------------- //
template<typename T>
class const_poly_ref;

## for struct in structs
template<>
class const_poly_ref<{{ struct.qualified_name }}> {
public:
    template<typename Object>
    const_poly_ref(const Object& object) {
        Obj_ = &object;
        Ops_ = &Impl::Traits<{{ struct.qualified_name }}>::OpsFor<Object>;
    }

## for method in struct.methods
{% if method.qualifiers == " const" %}
{% if method.signature == "" %}
    {{ method.return_type }} {{ method.name }}(){{ method.qualifiers }} { return Ops_->{{ method.name }}Func(Obj_); }
{% else %}
    {{ method.return_type }} {{ method.name }}({{ method.signature }}){{ method.qualifiers }} { return Ops_->{{ method.name }}Func(Obj_, {{ method.args }}); }
{% endif %}
{% endif %}
## endfor

private:
    void* Obj_;
    const Impl::Traits<{{ struct.qualified_name }}>::Ops* Ops_;
};

## endfor
// ------------- declare poly_ptr ------------- //
template<typename T>
class poly_ptr {
public:
    poly_ptr() = default;
    poly_ptr(std::nullptr_t) {};

    template<typename Object>
    poly_ptr(Object* object) {
        if (object != nullptr) {
            ref_.emplace(*object);
        }
    }

    poly_ref<T>& operator*() {
        return ref_.value();
    }

    poly_ref<T>* operator->() {
        return &ref_.value();
    }

private:
    std::optional<poly_ref<T>> ref_;
};

// ------------- declare const_poly_ptr ------------- //
template<typename T>
class const_poly_ptr {
public:
    const_poly_ptr() = default;
    const_poly_ptr(std::nullptr_t) {};

    template<typename Object>
    const_poly_ptr(const Object* object) {
        if (object != nullptr) {
            ref_.emplace(*object);
        }
    }

    const_poly_ref<T>& operator*() {
        return ref_.value();
    }

    const_poly_ref<T>* operator->() {
        return &ref_.value();
    }

private:
    std::optional<const_poly_ref<T>> ref_;
};

} // namespace Waffle
