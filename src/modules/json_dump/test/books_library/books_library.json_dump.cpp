// Generated by the Waffle++ code generator. DO NOT EDIT!
// source: books_library.h

#include <array>
#include <deque>
#include <forward_list>
#include <list>
#include <optional>
#include <sstream>
#include <vector>

#include <waffle/modules/json_dump/json_dump.h>

#include "books_library.h"

namespace Waffle {

namespace Impl {

template<class, template<class...> class> inline constexpr bool is_specialization = false;
template<template<class...> class T, class... Args> inline constexpr bool is_specialization<T<Args...>, T> = true;

template<typename T> concept JsonNullable = is_specialization<T, std::optional>;
template<typename T> concept JsonArray =
    is_specialization<T, std::vector> || is_specialization<T, std::deque> ||
    is_specialization<T, std::list> || is_specialization<T, std::forward_list> ||
    is_specialization<T, std::array>;
template<typename T> concept JsonObject = std::is_class_v<T> && !is_specialization<T, std::basic_string>;

template<typename T>
void DumpRoot(nlohmann::json& j, const T& value);

template<typename T>
void ParseRoot(T& t, const nlohmann::json& value);

template<JsonNullable T>
void DumpNullable(nlohmann::json& j, const T& value) {
    if (value.has_value()) {
        DumpRoot(j, *value);
    }
}

template<JsonNullable T>
void ParseNullable(T& t, const nlohmann::json& value) {
    if (!value.is_null()) {
        ParseRoot(t.emplace(), value);
    }
}

template<JsonArray T>
void DumpArray(nlohmann::json& j, const T& value) {
    j = nlohmann::json::array();
    for (auto iter = value.begin(); iter != value.end(); ++iter) {
        DumpRoot(j.emplace_back(), *iter);
    }
}

template<JsonArray T>
void ParseArray(T& t, const nlohmann::json& value) {
    for (auto iter = value.begin(); iter != value.end(); ++iter) {
        ParseRoot(t.emplace_back(), *iter);
    }
}

template<JsonObject T>
void DumpObject(nlohmann::json& j, const T& value);

template<JsonObject T>
void ParseObject(T& t, const nlohmann::json& value);

template<typename T>
void DumpPrimitive(nlohmann::json& j, const T value) {
    j = value;
}

template<typename T>
void ParsePrimitive(T& t, const nlohmann::json& value) {
    t = value;
}

template<>
inline void DumpObject(nlohmann::json& j, const model::LatLon& value) {
    j = nlohmann::json::object();
    DumpPrimitive(j["lat"], value.Lat);
    DumpPrimitive(j["lon"], value.Lon);
}

template<>
inline void DumpObject(nlohmann::json& j, const model::Book& value) {
    j = nlohmann::json::object();
    DumpPrimitive(j["name"], value.Name);
    DumpPrimitive(j["author"], value.Author);
    DumpPrimitive(j["year"], value.Year);
}

template<>
inline void DumpObject(nlohmann::json& j, const model::Library& value) {
    j = nlohmann::json::object();
    DumpArray(j["books"], value.Books);
    DumpNullable(j["description"], value.Description);
    DumpObject(j["address"], value.Address);
}

template<>
inline void ParseObject(model::LatLon& t, const nlohmann::json& value) {
    ParsePrimitive(t.Lat, value["lat"]);
    ParsePrimitive(t.Lon, value["lon"]);
}

template<>
inline void ParseObject(model::Book& t, const nlohmann::json& value) {
    ParsePrimitive(t.Name, value["name"]);
    ParsePrimitive(t.Author, value["author"]);
    ParsePrimitive(t.Year, value["year"]);
}

template<>
inline void ParseObject(model::Library& t, const nlohmann::json& value) {
    ParseArray(t.Books, value["books"]);
    ParseNullable(t.Description, value["description"]);
    ParseObject(t.Address, value["address"]);
}

template<typename T>
void DumpRoot(nlohmann::json& j, const T& value) {
    if constexpr (JsonNullable<T>) {
        DumpNullable(j, value);
    } else if constexpr (JsonArray<T>) {
        DumpArray(j, value);
    } else if constexpr (JsonObject<T>) {
        DumpObject(j, value);
    } else {
        DumpPrimitive(j, value);
    }
}

template<typename T>
void ParseRoot(T& t, const nlohmann::json& value) {
    if constexpr (JsonNullable<T>) {
        ParseNullable(t, value);
    } else if constexpr (JsonArray<T>) {
        ParseArray(t, value);
    } else if constexpr (JsonObject<T>) {
        ParseObject(t, value);
    } else {
        ParsePrimitive(t, value);
    }
}

} // namespace Impl

template<typename T>
nlohmann::json ToJson(const T& value) {
    nlohmann::json j;
    Impl::DumpRoot(j, value);
    return j;
}

template nlohmann::json ToJson<model::LatLon>(const model::LatLon&);
template nlohmann::json ToJson<std::vector<model::LatLon>>(const std::vector<model::LatLon>&);
template nlohmann::json ToJson<std::optional<model::LatLon>>(const std::optional<model::LatLon>&);

template nlohmann::json ToJson<model::Book>(const model::Book&);
template nlohmann::json ToJson<std::vector<model::Book>>(const std::vector<model::Book>&);
template nlohmann::json ToJson<std::optional<model::Book>>(const std::optional<model::Book>&);

template nlohmann::json ToJson<model::Library>(const model::Library&);
template nlohmann::json ToJson<std::vector<model::Library>>(const std::vector<model::Library>&);
template nlohmann::json ToJson<std::optional<model::Library>>(const std::optional<model::Library>&);

template<typename T>
T FromJson(const nlohmann::json& value) {
    T t;
    Impl::ParseRoot(t, value);
    return t;
}

template model::LatLon FromJson<model::LatLon>(const nlohmann::json&);
template std::vector<model::LatLon> FromJson<std::vector<model::LatLon>>(const nlohmann::json&);
template std::optional<model::LatLon> FromJson<std::optional<model::LatLon>>(const nlohmann::json&);

template model::Book FromJson<model::Book>(const nlohmann::json&);
template std::vector<model::Book> FromJson<std::vector<model::Book>>(const nlohmann::json&);
template std::optional<model::Book> FromJson<std::optional<model::Book>>(const nlohmann::json&);

template model::Library FromJson<model::Library>(const nlohmann::json&);
template std::vector<model::Library> FromJson<std::vector<model::Library>>(const nlohmann::json&);
template std::optional<model::Library> FromJson<std::optional<model::Library>>(const nlohmann::json&);

} // namespace Waffle
