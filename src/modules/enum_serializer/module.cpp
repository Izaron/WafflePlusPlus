#include "module.h"

#include <lib/comment/comment.h>
#include <lib/string_util/string_util.h>

#include <clang/AST/RecursiveASTVisitor.h>

using namespace Waffle;

namespace {

constexpr std::string_view MODULE_NAME = "enum_serializer";

constexpr std::string_view COMMAND_SERIALIZABLE = "serializable";
constexpr std::string_view COMMAND_STRING_VALUE = "stringvalue";

struct EnumData {
    using StringValues = std::vector<std::string>;
    using EnumConstantAndStringValue = std::pair<const clang::EnumConstantDecl*, StringValues>;

    const clang::EnumDecl* Decl;
    std::vector<EnumConstantAndStringValue> Constants;
};
using EnumDatas = std::vector<EnumData>;

class EnumVisitor : public clang::RecursiveASTVisitor<EnumVisitor> {
public:
    explicit EnumVisitor(clang::ASTContext& ctx) : Ctx_{ctx} {}

    bool VisitEnumDecl(clang::EnumDecl* decl) {
        if (ParseCommentData(Ctx_, *decl)->FindByName(COMMAND_SERIALIZABLE)) {
            AddSerializedEnum(decl);
        }
        return true;
    }

    const EnumDatas& GetDatas() const {
        return Datas_;
    }

private:
    void AddSerializedEnum(const clang::EnumDecl* decl) {
        auto& data = Datas_.emplace_back();
        data.Decl = decl;
        for (const auto* enumConstantDecl : decl->enumerators()) {
            data.Constants.emplace_back(enumConstantDecl, CalculateStringValues(enumConstantDecl));
        }
    }

    std::vector<std::string> CalculateStringValues(const clang::EnumConstantDecl* decl) {
        return {"dummy"};
    }

private:
    clang::ASTContext& Ctx_;
    EnumDatas Datas_;
};

class EnumPrinter {
public:
    explicit EnumPrinter(Context& ctx, const EnumDatas& datas)
        : Ctx_{ctx}
        , Datas_{datas}
    {}

    void Print() {
        auto& printer = Ctx_.FileManager.GetOrCreateFilePrinter("temp.cpp");
        printer << "// Generated by the Waffle++ code generator. DO NOT EDIT!\n";
        printer << "// source: " << Ctx_.InFile << "\n";
        printer << "int kek = 1337;\n";
        for (const auto& data : Datas_) {
            printer << "// values for " << StringUtil::QualifiedName(*data.Decl) << "\n";
            for (const auto& [constantDecl, stringValues] : data.Constants) {
                for (const auto& stringValue : stringValues) {
                    printer << "// " << StringUtil::QualifiedName(*constantDecl) << " <---> " << stringValue << "\n";
                }
            }
        }
    }

private:
    Context& Ctx_;
    const EnumDatas& Datas_;
};

} // namespace

std::string_view EnumSerializerModule::Name() const {
    return MODULE_NAME;
}

std::span<const std::string_view> EnumSerializerModule::Commands() const {
    static const std::vector<std::string_view> COMMANDS = {
        COMMAND_SERIALIZABLE,
        COMMAND_STRING_VALUE,
    };
    return COMMANDS;
}

void EnumSerializerModule::Do(Context& ctx) const {
    EnumVisitor visitor{ctx.AstContext};
    visitor.TraverseDecl(ctx.AstContext.getTranslationUnitDecl());
    if (const auto& enumDatas = visitor.GetDatas(); !enumDatas.empty()) {
        EnumPrinter printer{ctx, enumDatas};
        printer.Print();
    }
}

REGISTER_MODULE(EnumSerializerModule);
