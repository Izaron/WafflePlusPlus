// Generated by the Waffle++ code generator. DO NOT EDIT!
// source: custom_names.h

#include <vector>
#include <stdexcept>

#include <waffle/modules/enum_serializer/enum_serializer.h>

#include "custom_names.h"

namespace Waffle {

template<>
BookColor FromString<BookColor>(std::string_view value) {
    if (value == "red") {
        return BookColor::kRed;
    }
    if (value == "rot") {
        return BookColor::kRed;
    }
    if (value == "rouge") {
        return BookColor::kRed;
    }
    if (value == "green") {
        return BookColor::kGreen;
    }
    if (value == "grün") {
        return BookColor::kGreen;
    }
    if (value == "vert") {
        return BookColor::kGreen;
    }
    if (value == "blue") {
        return BookColor::kBlue;
    }
    if (value == "blau") {
        return BookColor::kBlue;
    }
    if (value == "bleu") {
        return BookColor::kBlue;
    }
    throw std::runtime_error("Can't parse value \"" + std::string{value} + "\" to enum type \"BookColor\"");
}

template<>
BookColor FromStringOrDefault<BookColor>(std::string_view value, BookColor defaultResult) {
    if (value == "red") {
        return BookColor::kRed;
    }
    if (value == "rot") {
        return BookColor::kRed;
    }
    if (value == "rouge") {
        return BookColor::kRed;
    }
    if (value == "green") {
        return BookColor::kGreen;
    }
    if (value == "grün") {
        return BookColor::kGreen;
    }
    if (value == "vert") {
        return BookColor::kGreen;
    }
    if (value == "blue") {
        return BookColor::kBlue;
    }
    if (value == "blau") {
        return BookColor::kBlue;
    }
    if (value == "bleu") {
        return BookColor::kBlue;
    }
    return defaultResult;
}

template<>
std::string_view ToString(BookColor value) {
    switch (value) {
        case BookColor::kRed: {
            return "red";
        }
        case BookColor::kGreen: {
            return "green";
        }
        case BookColor::kBlue: {
            return "blue";
        }
    }
    __builtin_unreachable();
}

template<>
std::span<const BookColor> GetAllEnumValues() {
    static const std::vector<BookColor> values{
        BookColor::kRed,
        BookColor::kGreen,
        BookColor::kBlue,
    };
    return values;
}

template<>
Number FromString<Number>(std::string_view value) {
    if (value == "zero") {
        return ZERO;
    }
    if (value == "null") {
        return ZERO;
    }
    if (value == "none") {
        return ZERO;
    }
    if (value == "empty") {
        return ZERO;
    }
    if (value == "absent") {
        return ZERO;
    }
    if (value == "missing") {
        return ZERO;
    }
    if (value == "invalid") {
        return ZERO;
    }
    if (value == "one") {
        return ONE;
    }
    if (value == "single") {
        return ONE;
    }
    if (value == "TWO") {
        return TWO;
    }
    if (value == "THREE") {
        return THREE;
    }
    throw std::runtime_error("Can't parse value \"" + std::string{value} + "\" to enum type \"Number\"");
}

template<>
Number FromStringOrDefault<Number>(std::string_view value, Number defaultResult) {
    if (value == "zero") {
        return ZERO;
    }
    if (value == "null") {
        return ZERO;
    }
    if (value == "none") {
        return ZERO;
    }
    if (value == "empty") {
        return ZERO;
    }
    if (value == "absent") {
        return ZERO;
    }
    if (value == "missing") {
        return ZERO;
    }
    if (value == "invalid") {
        return ZERO;
    }
    if (value == "one") {
        return ONE;
    }
    if (value == "single") {
        return ONE;
    }
    if (value == "TWO") {
        return TWO;
    }
    if (value == "THREE") {
        return THREE;
    }
    return defaultResult;
}

template<>
std::string_view ToString(Number value) {
    switch (value) {
        case ZERO: {
            return "zero";
        }
        case ONE: {
            return "one";
        }
        case TWO: {
            return "TWO";
        }
        case THREE: {
            return "THREE";
        }
    }
    __builtin_unreachable();
}

template<>
std::span<const Number> GetAllEnumValues() {
    static const std::vector<Number> values{
        ZERO,
        ONE,
        TWO,
        THREE,
    };
    return values;
}

} // namespace Waffle
